<p>#Next Permutation
&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. <br />
&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). <br />
<!--more-->
&gt;The replacement must be in-place, do not allocate extra memory. <br />
&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. <br />
&gt;1,2,3 → 1,3,2 <br />
&gt;3,2,1 → 1,2,3 <br />
&gt;1,1,5 → 1,5,1</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">nextPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">sort</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">j</span><span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>             
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure>

<p>第一反应 当然是O(n^2)的解决方案 显然会超时 <br />
但是超时的case刚好是1~100反向排列 <br />
当然是写了一个函数在最开头检测一下是不是反向的 <br />
然后直接reverse返回回去</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="nf">is_sorted</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>However 还是会超时 让我十分的纠结</p>

<p>搜索网络之后 得到如下解法 十分仰慕自己想出来的人</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">nextPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">index1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">num</span><span class="p">[</span><span class="n">index1</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">index1</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index1</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">index2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span><span class="o">&gt;</span><span class="n">num</span><span class="p">[</span><span class="n">index1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">index2</span><span class="p">],</span> <span class="n">num</span><span class="p">[</span><span class="n">index1</span><span class="p">]);</span>
                <span class="n">index1</span><span class="o">++</span><span class="p">;</span>
                <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">index1</span><span class="p">,</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">index2</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span></code></pre></figure>

<p>即反向搜索 理想的情况应该是升序 (即正向降序) <br />
那么有数字违反趋势的话 就找一个最小的比它大的数来交换位置 <br />
余下的数组逆向就可以了</p>

<hr />
<p>近来不少同学拿到了诸如Google Microsoft的巨额offer <br />
要打起精神向同学们学习 <br />
一心专心在导师的项目上虽然收获不小 <br />
但可能不是最利于自己发展的选择 毕竟现在的情况是毕业之后要先在工业界混一下 <br />
所以应该花更多的时间在准备面试题上面 <br />
共勉!</p>
