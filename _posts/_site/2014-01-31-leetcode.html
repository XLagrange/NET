<h1 id="single-number">Single Number</h1>
<blockquote>
  <p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
</blockquote>

<!--more-->
<blockquote>
  <p>Note: <br />
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">^=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>因为任何数的同或之后是0, 所以如果最后剩下一个数字, 那么就是它单个了</p>

<h1 id="single-number-ii">Single Number II</h1>
<blockquote>
  <p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
</blockquote>

<blockquote>
  <p>Note: <br />
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">array</span><span class="p">[</span><span class="mi">31</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">k</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">31</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="n">array</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>存在通用的解法 也就是把每一个int展开成二进制的形式 <br />
除了某一个数字 其他所有的都重复了k次 <br />
那么展开的二进制之和 每一位1都应该是k的倍数 <br />
但是因为有了那个single number的存在 导致除以k之后会有余数 <br />
那么显然余数就是single number了</p>

<hr />
<p># 关于春节
今天是甲午马年新年初一 <br />
比起去年的春节 今年适应了许多 几乎没有觉得有任何的孤单或者不知所措 <br />
&gt;学习 coding 聚会 有条不紊</p>

<p>今年是本命年 <br />
听不少长辈及略微年长的同学都提醒要小心 以及要宽心 因为可能会有很多的不顺 <br />
所以好奇查了一下今年的运势 <br />
乃有算命先生提到 今年甲午马属金 而90年生的马儿是土马 <br />
所以对于90年马儿们来说 是大吉的一年; <br />
而对于54 66 78 02年的马儿们来说 是大凶的一年 <br />
对于我来说 2014年确实是至关重要的一年</p>

<blockquote>
  <p>会在这一年master毕业 <br />
会去尝试更多的面试 更多的工作机会 地点的选择 <br />
顺利的话应该也会去很多地方旅游 拍更多漂亮的照片</p>
</blockquote>

<p>当然希望在新的一年中顺顺利利 心想事成 <br />
不过如果生活定要苦我心智 让我学习一些智慧的话 当然也只有虚心求教 <br />
底线当然是 望身体健康</p>

<hr />
<p># 关于1月
&gt;跑步</p>

<p>本月跑步的里程超过了80公里 <br />
离月破100公里还有一点的距离 <br />
不过因为1月7号才回到waterloo <br />
所以缺了一点公里数也属于正常 <br />
望2月保持 <br />
&gt;代码</p>

<p>1月几乎完全重写了dfs <br />
代码超过2000行 <br />
能力可以看出相较上一个study term 有明显的进步 <br />
望保持对于代码的热情 <br />
在2月可以把测试数据拿到</p>
