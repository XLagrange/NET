<p>#Sort Colors</p>

<blockquote>
  <p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. <br />
<!--more--></p>
</blockquote>

<blockquote>
  <p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
</blockquote>

<blockquote>
  <p>Note: <br />
You are not suppose to use the library’s sort function for this problem.</p>
</blockquote>

<blockquote>
  <p>click to show follow up.</p>
</blockquote>

<blockquote>
  <p>Follow up: <br />
A rather straight forward solution is a two-pass algorithm using counting sort. <br />
First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>
</blockquote>

<blockquote>
  <p>Could you come up with an one-pass algorithm using only constant space?</p>
</blockquote>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">sortColors</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">right</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">cur_index</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">cur_index</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">cur_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cur_index</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">cur_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">cur_index</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
            <span class="n">right</span><span class="o">--</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">cur_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">cur_index</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="n">cur_index</span><span class="o">++</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>所以其实很简单… 走起来想到的就是这个过一次的解法</p>

<hr />

<p>今天在多伦多美签, 排在我之前有一个姑娘, 英文很不好</p>

<p>在多次使用英文沟通无果之后 白人签证官冲着姑娘用标准普通话说 <br />
“我是在问你 你什么时候可以毕业” <br />
然后场面很尴尬 <br />
不过签证官人很好, 还是放过了姑娘 <br />
&gt;话说您英文这么烂 怎么在加拿大活下来的</p>

<hr />

<p>今天开始看 王晓风的 <从你美丽的流域>   
原来一直作为QQ签名的一句话   
"有一天我们忽然长大 因为爱"   
是出自这里   
读到这里 突然觉得一片光明</从你美丽的流域></p>
