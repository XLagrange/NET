<h1 id="path-sum">Path Sum</h1>
<blockquote>
  <p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
</blockquote>

<!--more-->

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">PathSum</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">PathSum</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_sum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected_sum</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">expected_sum</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">|=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PathSum</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">expected_sum</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PathSum</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">expected_sum</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h1 id="path-sum-ii">Path Sum II</h1>
<blockquote>
  <p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pathSum</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur_path</span><span class="p">;</span>
    <span class="n">pathSum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">cur_path</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">pathSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur_path</span><span class="p">,</span> 
             <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_sum</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">expected_sum</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cur_path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">expected_sum</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cur_path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pathSum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">cur_path</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> 
                <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">expected_sum</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pathSum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">cur_path</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> 
                <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">expected_sum</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>两道题都是简单的recursion也被接受了 今天略累 就不琢磨iteration了</p>

<hr />
<p># 关于控制力
今日在知乎上读到一篇关于控制力的回答 很好 愿在此分享一下 <br />
链接: http://www.zhihu.com/question/22238159 <br />
人人都知道要先解决重要且紧急的事 然后主要时间都花在重要但不紧急的事情上 <br />
然后让不重要无论紧急与否的事滚都一边去 <br />
但是怎么去区分一个事情现在重要不重要 将来会不会变得很重要 <br />
这个太看觉悟 也难以抉择</p>

<p>不过换一个说法 我们应该把时间花在可以被积累下来的事情上面 <br />
那么无论对于现在的我们此事是否重要 <br />
相信都会在合适的时间给予我们相应的帮助</p>

<p>如答案所说: 诗歌可以被积累 书法可以被积累(Jobs的案例) <br />
那么相应的 也许现在我每天做一题leetcode算法 不会有成果凸显出来 <br />
但作为要长期耕耘代码的牲畜来说 相信长期的积累 还是会有其意义 <br />
愿坚持</p>

<hr />
<p># 关于project
周末算是达成一个milestone 对于dfs里面namenode datanode client都有了单独测试 <br />
那么在下个礼拜 希望可以完成组合起来的测试 <br />
祝一切都好</p>
